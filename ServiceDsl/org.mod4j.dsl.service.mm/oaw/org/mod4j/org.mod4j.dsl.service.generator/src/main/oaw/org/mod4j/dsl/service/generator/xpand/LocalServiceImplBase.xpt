«REM»
      Copyright (c) 2009 Ordina and committers to Mod4j
      All rights reserved. This program and the accompanying materials
      are made available under the terms of the Eclipse Public License v1.0
      which accompanies this distribution, and is available at
      http://www.eclipse.org/legal/epl-v10.html

      Contributors:
          Ordina - initial implementation
«ENDREM»
«IMPORT ServiceDsl»
«IMPORT crossx»
«IMPORT org::mod4j::dslcommon::xpand::java»

«IMPORT org::mod4j::dslcommon::xpand::java»

«EXTENSION org::mod4j::dsl::service::mm::xtend::ServiceMethod»
«EXTENSION org::mod4j::dslcommon::xtend::generatorutil»
«EXTENSION org::mod4j::common::xtend::NameMapper»
«EXTENSION org::mod4j::dslcommon::xtend::ProjectProperties»
«EXTENSION org::mod4j::crossx::broker::xtend::Crossx»

«DEFINE LocalServiceImplBase FOR ServiceModel»
    «EXPAND JavaComments::regenerationWarningHeader ("Mod4j ServiceDsl generator: LocalServiceImplBase.xpt") FOR this»

    package «getLocalServicePackage()»;

    import java.util.List;
    import java.util.Set;
    import java.util.ArrayList;
    import org.springframework.util.Assert;
    import org.mod4j.runtime.queries.SearchParameters;
    «FOREACH this.dtoReferences AS dto -»
    import «getDtoPackage()».«javaClassName(dto.name)»;
    «ENDFOREACH»
    «FOREACH this.dtoReferences.select(dto|dto.businessClass() != "void") AS dto -»
    import «javaDaoInterfacePath(dto.businessClass())»; 
    import «javaTranslatorClassPath(dto.name)»;
    import «javaDomainClassPath(dto.businessClass())»;
    import «javaDomainExampleClassPath(dto.businessClass())»;
    «ENDFOREACH»

    /**
     * @author Generated by Mod4j
     */
    abstract public class «javaLocalServiceBaseClass(name)» implements «javaLocalServiceInterface(name)» {

    «FOREACH this.uniqueBusinessClasses() AS bc -»
        «EXPAND FieldGetterSetter::field(javaDaoInterface(bc)) FOR javaDaoInterface(bc).toFirstLower()»
    «ENDFOREACH»

    «FOREACH this.getAllBusinessClassDtoSymbols() AS classDtoSymbol»
        «EXPAND FieldGetterSetter::field(javaTranslatorClass(classDtoSymbol.name)) FOR javaTranslatorClass(classDtoSymbol.name).toFirstLower()»
    «ENDFOREACH»

    «FOREACH this.methods.typeSelect(SpecialMethod) AS method»
        «IF method.type == MethodType::CREATE»
            «EXPAND CreateMethod FOR method»
        «ENDIF»
        «IF method.type == MethodType::READ»
            «EXPAND ReadMethod FOR method»
        «ENDIF»
        «IF method.type == MethodType::UPDATE»
            «EXPAND UpdateMethod FOR method»
        «ENDIF»
        «IF method.type == MethodType::DELETE»
            «EXPAND DeleteMethod FOR method»
        «ENDIF»
        «IF method.type == MethodType::LISTALL»
            «EXPAND ListallMethod FOR method»
        «ENDIF»
        «IF method.type == MethodType::FIND»
            «EXPAND FindMethod FOR method»
        «ENDIF»
    «ENDFOREACH»

    «EXPAND CountMethod FOREACH this.uniqueMethods(MethodType::LISTALL) »

    «EXPAND Associations FOR this»
    }
«ENDDEFINE»

«DEFINE Parameter FOR Parameter»
«JavaType(type)»  «this.name»
«ENDDEFINE»

«DEFINE CreateMethod FOR SpecialMethod»
    /**
     * {@inheritDoc}
     */
    public Long «this.name»(«JavaType(this.dto)» object){
        return «javaDaoInterface(dto.businessClass()).toFirstLower()».add(«javaTranslatorClass(dto.name).toFirstLower()».fromDto(object));
    }
«ENDDEFINE»

«DEFINE ReadMethod FOR SpecialMethod»
    /**
     * {@inheritDoc}
     */
    public «JavaType(this.dto)» «this.name»(Long id) {
        «javaDomainClass(dto.businessClass())» result =
              «javaDaoInterface(dto.businessClass()).toFirstLower()».retrieve(id);
        return (result == null) ? null : «javaTranslatorClass(dto.name).toFirstLower()».toDto(result);
    }
«ENDDEFINE»

«DEFINE UpdateMethod FOR SpecialMethod»
«LET this.model.methods.typeSelect(SpecialMethod).select(m|m.type == MethodType::READ && (m.dto == this.dto)).first() AS readmethod»
    /**
     * {@inheritDoc}
     */
    public void «this.name»(«JavaType(this.dto)» object) {
        «javaDomainClass(dto.businessClass())» domainObject = «javaDaoInterface(dto.businessClass()).toFirstLower()».retrieve(object.getId());
        «javaTranslatorClass(dto.name).toFirstLower()».fromDto(object, domainObject);
    }
«ENDLET»
«ENDDEFINE»

«DEFINE DeleteMethod FOR SpecialMethod»
    /**
     * {@inheritDoc}
     */
    public void «this.name»(«JavaType(this.dto)» object) {
        Assert.notNull(object, "argument [object] may not be null");
        «javaDomainClass(dto.businessClass())» existing =
            «javaDaoInterface(dto.businessClass()).toFirstLower()».retrieve(object.getId());
        «javaDaoInterface(dto.businessClass()).toFirstLower()».delete(existing);
    }
«ENDDEFINE»

«DEFINE ListallMethod FOR SpecialMethod»
    /**
     * {@inheritDoc}
     */
    public List<«JavaType(this.dto)»> «this.name»() {
        List<«this.dto.businessClass()»> all = «javaDaoInterface(dto.businessClass()).toFirstLower()».listAll();
        List<«JavaType(this.dto)»> result = new ArrayList<«JavaType(this.dto)»>(all.size());

        for («this.dto.businessClass()» object : all) {
            «JavaType(this.dto)» item = «javaTranslatorClass(dto.name).toFirstLower()».toDto(object);
            result.add(item);
        }
        return result;
    }

    /**
     * {@inheritDoc}
     */
    public List<«JavaType(this.dto)»> «this.name»(final int firstResult, final int maxResults) {
        List<«this.dto.businessClass()»> range = «javaDaoInterface(dto.businessClass()).toFirstLower()».listPage(firstResult, maxResults);
        List<«JavaType(this.dto)»> result = new ArrayList<«JavaType(this.dto)»>(range.size());

        for («this.dto.businessClass()» object : range) {
            «JavaType(this.dto)» item = «javaTranslatorClass(dto.name).toFirstLower()».toDto(object);
            result.add(item);
        }
        return result;
    }

    /**
     * {@inheritDoc}
     */
    public List<«JavaType(this.dto)»> «this.name»(final int firstResult, final int maxResults,
        final String sortProperty, final boolean isAscending) {
        List<«this.dto.businessClass()»> range = «javaDaoInterface(dto.businessClass()).toFirstLower()».listPage(firstResult, maxResults, sortProperty, isAscending);
        List<«JavaType(this.dto)»> result = new ArrayList<«JavaType(this.dto)»>(range.size());

        for («this.dto.businessClass()» object : range) {
            «JavaType(this.dto)» item = «javaTranslatorClass(dto.name).toFirstLower()».toDto(object);
            result.add(item);
        }
        return result;
    }
«ENDDEFINE»

«DEFINE CountMethod FOR SpecialMethod»
    /**
     * {@inheritDoc}
     */
    public long count«this.dto.businessClass()»s() {
        return «javaDaoInterface(dto.businessClass()).toFirstLower()».count();
    }
«ENDDEFINE»

«DEFINE FindMethod FOR SpecialMethod»
«LET JavaType(this.dto) AS dtoType»
«LET javaDomainClass(this.dto.businessClass()) AS Class»
    /**
     * {@inheritDoc}
     */
    public List<«dtoType»> findByExample(final «dtoType» exampleDto) {
        «this.dto.businessClass().javaDomainExampleClass()» example =
                      «javaTranslatorClass(dto.name).toFirstLower()».exampleFromDto(exampleDto);

        List<«Class»> found = «javaDaoInterface(Class).toFirstLower()».findByExample(example);
        List<«dtoType»> result = new ArrayList<«dtoType»>(found.size());

        for («Class» object : found) {
            «dtoType» item = «javaTranslatorClass(dto.name).toFirstLower()».toDto(object);
            result.add(item);
        }
        return result;
    }

    /**
     * {@inheritDoc}
     */
    public List<«JavaType(this.dto)»> findByExample(final «JavaType(this.dto)» exampleDto, final SearchParameters parameters) {
        «this.dto.businessClass().javaDomainExampleClass()» example =
                      «javaTranslatorClass(dto.name).toFirstLower()».exampleFromDto(exampleDto);

        List<«this.dto.businessClass()»> range = «javaDaoInterface(Class).toFirstLower()».findByExample(example, parameters);
        List<«JavaType(this.dto)»> result = new ArrayList<«JavaType(this.dto)»>(range.size());

        for («this.dto.businessClass()» object : range) {
            «JavaType(this.dto)» item = «javaTranslatorClass(dto.name).toFirstLower()».toDto(object);
            result.add(item);
        }
        return result;
    }

    /**
     * {@inheritDoc}
     */
    public long countByExample(final «JavaType(this.dto)» exampleDto) {
        return «javaDaoInterface(Class).toFirstLower()».countByExample(«javaTranslatorClass(dto.name).toFirstLower()».exampleFromDto(exampleDto));
    }
    
    /**
     * {@inheritDoc}
     */
    public long countByExample(final «JavaType(this.dto)» exampleDto, final SearchParameters parameters) {
        return «javaDaoInterface(Class).toFirstLower()».countByExample(«javaTranslatorClass(dto.name).toFirstLower()».exampleFromDto(exampleDto), parameters);
    }
«ENDLET»
«ENDLET»
«ENDDEFINE»

«DEFINE Associations FOR ServiceModel»
    «FOREACH this.methods.typeSelect(AssociationMethod) AS method»
    «LET getAssociation(method) AS assoc»
    «LET getPropertyValue(assoc, "Multiplicity") AS mult»

        «REM»The addTo or set method «ENDREM»
        «IF method.type == MethodType::ADDTO»
            «IF (mult == "ONE") »
                «EXPAND setMethod FOR method»
            «ELSE»
                «EXPAND addToMethod FOR method»
            «ENDIF»
        «ENDIF»

        «REM»The get method for multiplicity one or many«ENDREM»
        «IF method.type == MethodType::GETFROM»
            «IF (mult == "ONE") »
                «EXPAND getOneMethod FOR method»
            «ELSE»
                «EXPAND getManyMethod FOR method»
            «ENDIF»
        «ENDIF»

        «REM»And the removeFrom method«ENDREM»
        «IF method.type == MethodType::REMOVEFROM»
        /**
         * {@inheritDoc}
         */
        public void «method.name»(«method.main.name» whole, «method.part.name» part) {
        
            Assert.notNull(whole, "argument [whole] may not be null");
            Assert.notNull(part, "argument [part] may not be null");
            
            «method.part.businessClass()» partObject = «javaDaoInterface(method.part.businessClass()).toFirstLower()».retrieve(part.getId());
            «method.main.businessClass()» wholeObject = «javaDaoInterface(method.main.businessClass()).toFirstLower()».retrieve(whole.getId());
            wholeObject.removeFrom«method.rolename.toFirstUpper()»(partObject);
        }
        «ENDIF»
    «ENDLET»
    «ENDLET»
    «ENDFOREACH»
«ENDDEFINE»

«DEFINE addToMethod FOR AssociationMethod»
    /**
     * {@inheritDoc}
     */
    public void «this.name»(«this.main.name» whole, «this.part.name» part) {
    
        Assert.notNull(whole, "argument [whole] may not be null");
        Assert.notNull(part, "argument [part] may not be null");

        «this.part.businessClass()» partBusinessObject = «javaDaoInterface(part.businessClass()).toFirstLower()».retrieve(part.getId());
        Assert.notNull(partBusinessObject, "Con not add «part.businessClass()» to a non-existing «main.businessClass()»: [" + whole.toString() + "]");
        
        «this.main.businessClass()» mainBusinessObject = «javaDaoInterface(main.businessClass()).toFirstLower()».retrieve(whole.getId());
        Assert.notNull(mainBusinessObject, "Con not add «part.businessClass()» to «main.businessClass()»: «part.businessClass()» does not exitst: [" + whole.toString() + "]");
        
        mainBusinessObject.addTo«this.rolename.toFirstUpper()»(partBusinessObject);
    }
«ENDDEFINE»

«DEFINE setMethod FOR AssociationMethod»
    /**
     * {@inheritDoc}
     */
    public void «this.name»(«this.main.name» whole, «this.part.name» part) {
    
        Assert.notNull(whole, "argument [whole] may not be null");
        
        «this.part.businessClass()» partBusinessObject = null;
        if (part != null) {
            partBusinessObject = «javaDaoInterface(part.businessClass()).toFirstLower()».retrieve(part.getId());
        }
        «this.main.businessClass()» mainBusinessObject = «javaDaoInterface(main.businessClass()).toFirstLower()».retrieve(whole.getId());
        mainBusinessObject.set«this.rolename.toFirstUpper()»(partBusinessObject);
    }
«ENDDEFINE»

«DEFINE getOneMethod FOR AssociationMethod»
    /**
     * {@inheritDoc}
     */
    public «JavaType(this.part)» «this.name»(«this.main.name» source){
    
        Assert.notNull(source, "argument [source] may not be null");
        
        «this.part.businessClass()» target = null;
        «this.main.businessClass()» sourceBusinessObject = «javaDaoInterface(main.businessClass()).toFirstLower()».retrieve(source.getId());
        Assert.notNull(sourceBusinessObject, "Can not «this.name» for a non existing «this.main.name»: [" + source.toString() + "]");
        
        target = «javaDaoInterface(part.businessClass()).toFirstLower()».retrieve(sourceBusinessObject.get«this.part.businessClass()»().getId());
        return «javaTranslatorClass(this.part.name).toFirstLower()».toDto(target);
    }
«ENDDEFINE»

«DEFINE getManyMethod FOR AssociationMethod»
    /**
     * {@inheritDoc}
     */
    public List<«JavaType(this.part)»> «this.name»(«this.main.name» source) {
    
        Assert.notNull(source, "argument [source] may not be null");
        
        «this.main.businessClass()» businessSource = «javaDaoInterface(main.businessClass()).toFirstLower()».retrieve(source.getId());
        Set<«this.part.businessClass()»> parts = businessSource.get«this.rolename.toFirstUpper()»();
        List<«this.part.name»> result = new ArrayList<«this.part.name»>(parts.size());

        for («this.part.businessClass()» element: parts) {
            «this.part.name» item = «javaTranslatorClass(this.part.name).toFirstLower()».toDto(element);
            result.add(item);
        }
        return result;
    }
«ENDDEFINE»
