«REM»
	  Copyright (c) 2009 Ordina and committers to Mod4j
	  All rights reserved. This program and the accompanying materials
	  are made available under the terms of the Eclipse Public License v1.0
	  which accompanies this distribution, and is available at
	  http://www.eclipse.org/legal/epl-v10.html
	 
	  Contributors:
	      Ordina - initial implementation
«ENDREM»
«IMPORT ServiceDsl»
«IMPORT crossx»
«IMPORT org::mod4j::dslcommon::xpand::java»

«EXTENSION org::mod4j::dsl::service::mm::xtend::ServiceMethod»
«EXTENSION org::mod4j::dslcommon::xtend::generatorutil»
«EXTENSION org::mod4j::common::xtend::NameMapper»
«EXTENSION org::mod4j::dslcommon::xtend::ProjectProperties»
«EXTENSION org::mod4j::crossx::broker::xtend::Crossx» 

«DEFINE LocalService FOR ServiceModel -»
    «EXPAND JavaComments::regenerationWarningHeader ("Mod4j ServiceDsl generator: LocalService.xpt") FOR this»

	package «getLocalServicePackage()»;

	import java.util.List;
	import org.mod4j.runtime.queries.SearchParameters;
    «FOREACH this.dtoReferences AS dto -»
	    import «getServiceRootPackage()».dto.«dto.name»;
	«ENDFOREACH»
	/**
	 * @author Generated by Mod4j
	 */
	public interface «javaLocalServiceInterface(name)» {

	«FOREACH this.methods.typeSelect(CustomMethod) AS method»
	    «EXPAND CustomMethod FOR method»
	«ENDFOREACH»	

	«FOREACH this.methods.typeSelect(SpecialMethod) AS method»
		«IF method.type == MethodType::CREATE»
			«EXPAND CreateMethod FOR method»
		«ENDIF»
		«IF method.type == MethodType::READ»
			«EXPAND ReadMethod FOR method»
		«ENDIF»
		«IF method.type == MethodType::UPDATE»
			«EXPAND UpdateMethod FOR method»
		«ENDIF»
		«IF method.type == MethodType::DELETE»
			«EXPAND DeleteMethod FOR method»
		«ENDIF»
		«IF method.type == MethodType::LISTALL»
			«EXPAND ListallMethod FOR method»
		«ENDIF»
		«IF method.type == MethodType::FIND»
			«EXPAND FindMethod FOR method»
		«ENDIF»
	«ENDFOREACH»
	
	«EXPAND CountMethod FOREACH this.uniqueMethods(MethodType::LISTALL) »	

	«EXPAND Associations FOR  this»
	}
«ENDDEFINE»

«DEFINE CustomMethod FOR CustomMethod -»
«print("Custom method [" + this.name + "] param ["  + this.outParameter + "]")»
«LET JavaParamType(this.outParameter) AS returnType»
	/** 
	 * Description: «this.description».
	 «FOREACH inParameters AS param-»
	 * @param «param.name» A custom parameter
	 «ENDFOREACH-»
	«IF returnType == "void"-» «ELSE-» 
	 * @return «returnType» 
	«ENDIF-»
     */
    public «returnType» «this.name» ( «EXPAND Parameter FOREACH this.inParameters SEPARATOR ','» );
 «ENDLET»
 «ENDDEFINE»

«DEFINE Parameter FOR Parameter -»
«JavaParamType(this)»  «this.name»
«ENDDEFINE»

«DEFINE CreateMethod FOR SpecialMethod -»
    /**
     * Creates a new «this.dto.name».
     * «description»
     * @param object 
     *            The «this.dto.name» to create.
     * @return the id of the «this.dto.name» created.
     */
    public Long «this.name»(«JavaType(this.dto)» object);
«ENDDEFINE»

«DEFINE ReadMethod FOR SpecialMethod -»
    /**
     * Reads an existing «this.dto.name».
     * «description»
     * @param id
     *            The id of the «this.dto.name» to read.
     * @return The «this.dto.name» with id, or null if no object with id exists.
     */
    public «JavaType(this.dto)» «this.name»(Long id);
«ENDDEFINE»

«DEFINE UpdateMethod FOR SpecialMethod -»
    /**
     * Updates an existing «this.dto.name».
     * «description»
     * @param object
     *            The «this.dto.name» containing the modifications for the corresponding «JavaType(this.dto)»
     */
    public void «this.name»(«JavaType(this.dto)» object);
«ENDDEFINE»

«DEFINE DeleteMethod FOR SpecialMethod -»
    /**
     * Deletes an existing «this.dto.name».
     * «description»
     * @param object
     *            The «this.dto.name» object to delete.
     */
    public void «this.name»(«JavaType(this.dto)» object);
«ENDDEFINE»

«DEFINE ListallMethod FOR SpecialMethod -»
    /**
     * Returns a list of all objects of type «JavaType(this.dto)».
     * «description»
     *
     * @return the list of all «JavaType(this.dto)» objects.
     */
    public List<«JavaType(this.dto)»> «this.name»();

    /**
     * Reads a range (page) of objects of type «JavaType(this.dto)».
     * 
     * @param firstResult - the index of the first result object to be retrieved (numbered from 0)
     * @param maxResults - the maximum number of result objects to retrieve (or <=0 for no limit) 
     * 
     * @return List containing 0 or more «JavaType(this.dto)» objects.
     *
     * @see {@link #«this.name»(int, int, String, boolean)}
     */
    public List<«JavaType(this.dto)»> «this.name»(final int firstResult, final int maxResults);
    
    /**
     * Reads an sorted range (page) of objects of type «JavaType(this.dto)».
     * 
     * @param firstResult - the index of the first result object to be retrieved (numbered from 0)
     * @param maxResults - the maximum number of result objects to retrieve (or <=0 for no limit) 
     * @param sortProperty - the property of the object to sort on
     * @param isAscending - should the retruned list be sorted ascending or descending? 
     *
     * @return ordered List containing 0 or more «JavaType(this.dto)» objects.
     *
     * @see {@link #«this.name»(int, int)} 
     */
    public List<«JavaType(this.dto)»> «this.name»(final int firstResult, final int maxResults,
        final String sortProperty, final boolean isAscending);
«ENDDEFINE»

«DEFINE CountMethod FOR SpecialMethod -»
    /**
     * Counts the number of existing objects of type «this.dto.businessClass()».
     * 
     * @return number of existing «this.dto.businessClass()» objects. 
     */
    public long count«this.dto.businessClass()»s();
«ENDDEFINE»

«DEFINE FindMethod FOR SpecialMethod -»

    /**
     * Finds all persisted objects of type «JavaType(this.dto)», that conform to the <code>example</code> object.
     *
     * @param example
     *            The objects to which the result objects need to conform.
     *
     * @return the list of all «JavaType(this.dto)» objects conforming to the example object.
     * @since 1.4
     */
    public List<«JavaType(this.dto)»> findByExample(«JavaType(this.dto)» example);
    
    /**
     * Finds all persisted objects of type «JavaType(this.dto)», that conform to the given <code>example</code> object, and
     * are constrained by the given search <code>parameters</code>.
     * 
     * @param example 
     *            The dto-object to which the result objects need to conform.
     * @param parameters 
     *            The search <code>parameters</code>.
     *
     * @return List containing zero or more «JavaType(this.dto)» objects.
     * @since 1.4 
     */
    public List<«JavaType(this.dto)»> findByExample(final «JavaType(this.dto)» example, final SearchParameters parameters);

    /**
     * Counts the number of persisted objects of type «this.dto.businessClass()», that conform to the given <code>example</code> object.
     *
     * @param example
     *            The dto-object to which the result objects must conform.
     * 
     * @return number of persisted «this.dto.businessClass()» objects that matches the <code>example</code>.
     * @since 1.4
     */
     public long countByExample(final «JavaType(this.dto)» example);

    /**
     * Counts the number of persisted objects of type «this.dto.businessClass()», that conform to the given <code>example</code> object,
     * and are constrained by the given search <code>parameters</code>.
     *
     * @param example
     *            The dto-object to which the result objects must conform.
     * @param parameters 
     *            The search <code>parameters</code>.
     * 
     * @return number of persisted «this.dto.businessClass()» objects that matches the <code>example</code>.
     * @since 1.4
     */
     public long countByExample(final «JavaType(this.dto)» example, final SearchParameters parameters);
     
«ENDDEFINE»

«DEFINE Associations FOR ServiceModel -»
	«FOREACH this.methods.typeSelect(AssociationMethod) AS method»
		«LET getAssociation(method) AS assoc» 
		«LET getPropertyValue(assoc, "Multiplicity") AS mult»
	    «LET ((mult == "ONE") ? "set" : "addTo") + method.rolename.toFirstUpper() AS genName»
	    	«IF method.type == MethodType::ADDTO»
	    	    /**
	    	     * Adds an «method.part.name» to an «method.main.name».
			     * «method.description»
			     * @param whole
			     *            The object to which to add.
			     * @param part
			     *            The object that is added to the whole.
	    	     */
	            public void «method.name»(«method.main.name» whole, «method.part.name» part);
			«ENDIF»
			
			«IF method.type == MethodType::REMOVEFROM»
	    	    /**
	    	     * Removes an «method.part.name» from an «method.main.name».
			     * «method.description»
			     * @param whole
			     *            The object from which to remove.
			     * @param part
			     *            The object that is removed from the whole.
	    	     */
	            public void «method.name»(«method.main.name» whole, «method.part.name» part);
			«ENDIF»
		
			«IF method.type == MethodType::GETFROM»
				«IF (mult == "ONE")»
		    	    /**
		    	     * Gets the «method.part.name» from an «method.main.name».
				     * «method.description»
				     * @param source
				     *            The object from which to get the «method.part.name»
				     * @return «JavaType(method.part)» 
		    	     */
	                public «JavaType(method.part)» «method.name»(«method.main.name» source);
				«ELSE»
		    	    /**
		    	     * Gets the «method.part.name» from «method.main.name».
				     * «method.description»
				     * @param source
				     *            The object from which to get the «method.part.name»
				     * @return «JavaType(method.part)» 
		    	     */
	                public List<«JavaType(method.part)»> «method.name»(«method.main.name» source);
				«ENDIF»
			«ENDIF»
		«ENDLET»
		«ENDLET»
		«ENDLET»
	«ENDFOREACH»
«ENDDEFINE»