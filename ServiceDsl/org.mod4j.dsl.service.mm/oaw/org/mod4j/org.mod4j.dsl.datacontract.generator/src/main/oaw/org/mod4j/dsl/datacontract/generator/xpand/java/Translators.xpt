«REM»
      Copyright (c) 2009 Ordina and committers to Mod4j
      All rights reserved. This program and the accompanying materials
      are made available under the terms of the Eclipse Public License v1.0
      which accompanies this distribution, and is available at
      http://www.eclipse.org/legal/epl-v10.html

      Contributors:
          Ordina - initial implementation
«ENDREM»
«IMPORT DataContractDsl»
«IMPORT org::mod4j::dslcommon::xpand::java»

«EXTENSION org::mod4j::dslcommon::xtend::generatorutil»
«EXTENSION org::mod4j::dslcommon::xtend::ProjectProperties»
«EXTENSION org::mod4j::common::xtend::NameMapper»
«EXTENSION org::mod4j::dsl::datacontract::generator::xtend::Dto»

«DEFINE createTranslator FOR Dto»
    «REM»No generation for this super type«ENDREM»
«ENDDEFINE»

«DEFINE createTranslator FOR BusinessClassDto»
    «LET this.properties.typeSelect(DtoAssociationRoleProperty) AS associationProperties»
        «EXPAND JavaComments::regenerationWarningHeader ("Mod4j DatacontractDsl generator: Translators.xpt") FOR this»

         package «getTranslatorsPackage()»;

         import java.util.HashMap;
         import java.util.Map;
         import java.util.HashSet;
         import java.util.Set;
         import org.springframework.util.Assert;
         import org.mod4j.runtime.exception.ConcurrentUpdateException;
         import «getDomainRootPackage()».«javaClassName(base.name)»;
         import «getDomainRootPackage()».«javaClassName(base.name)»Example;
         import «getDtoPackage()».«javaClassName(name)»;
         «FOREACH associationProperties AS assRef -»
             import «getDomainRootPackage()».«assRef.dtoType.getBaseDtoBusinessClassName()»;
             import «getDtoPackage()».«assRef.dtoType.getBaseDtoName()»;
         «ENDFOREACH»
        «FOREACH associationProperties AS assRef»
            import «getDataRootPackage()».«assRef.dtoType.getBaseDtoBusinessClassName()»Dao;
        «ENDFOREACH»

        /**
         * Translator for translating «javaClassName(base.name)» domain objects from- and to «javaClassName(name)» data transfer objects.
         *
         * @author generated by Mod4j
         */
         public class «javaTranslatorName(javaClassName(name))» {
        «FOREACH associationProperties.dtoType.getBaseDtoName().toSet() AS dtoName»
            «EXPAND FieldGetterSetter::field(javaTranslatorName(javaClassName(dtoName)))
                                  FOR javaTranslatorName(javaClassName(dtoName)).toFirstLower() »
        «ENDFOREACH»

        «FOREACH this.associationReferences.dtoType.getBaseDtoBusinessClassName().toSet() AS businessClassname»
            «EXPAND FieldGetterSetter::field(businessClassname + "Dao")
                                  FOR (businessClassname.toFirstLower() + "Dao") »
        «ENDFOREACH»

              «FOREACH properties.typeSelect(DtoDataProperty) AS dataProperty -»
                  «IF dataProperty.metaType == DtoEnumerationProperty -»
                      private «javaClassName(((DtoEnumerationProperty)dataProperty).type.name)»Translator «dataProperty.name»Translator = new «javaClassName(((DtoEnumerationProperty)dataProperty).type.name)»Translator();
                  «ENDIF»
              «ENDFOREACH»

                 /**
              «IF this.creatable»
                  * Translates a «javaClassName(name)» dto object into a «javaClassName(base.name)» domain object.
                  * A new domain object will be created passed to the {@link #fromDto(«javaClassName(name)», «javaClassName(base.name)»)}.
              «ENDIF».
                  *
                  * @param source The {@link «javaClassName(name)»} object to translate, may not be {@code null}.
                  * @return {@link «javaClassName(base.name)»}, the resulting domain object.
                  */
                 public «javaClassName(base.name)» fromDto(final «javaClassName(name)» source) {
                     return fromDto(source, new HashMap<Object, Object>());
                 }

                 «javaClassName(base.name)» fromDto(final «javaClassName(name)» source, final Map<Object, Object> translated) {
                  «REM»A DTO is NOT creatable if it does not contain all mandatory properties of the domain object. See CompleteDtc.ext. «ENDREM»
                  «IF this.creatable -»
                      Assert.notNull(source, "argument [source] may not be null");
                      Assert.isNull(source.getId(), "Can not translate a dto with existing id to a new domain object. Dto: " + source);
                      «javaClassName(base.name) -» target = new «javaClassName(base.name) -»(«EXPAND Constructors::addConstructorArgumentsList -»);
                      return fromDto(source, target, translated);
                  «ELSE -»
                      throw new IllegalArgumentException("This source dto does not contain all non-nullable properties of the domain object to be created: " + source.toString());
                  «ENDIF»
              }

             /**
              * Translates a «javaClassName(name)» dto object into a «javaClassName(base.name)» domain object. All properties in the dto will be mapped to the
              * corresponding property in the <code>target</code> domain object.
              *
              * @param source The {@link «javaClassName(name)»} object to translate, may not be {@code null}.
              * @param target The {@link «javaClassName(base.name)»} object translated from source, may not be {@code null}.
              * @return {@link «javaClassName(base.name)»}, the resulting domain object.
              */
              public «javaClassName(base.name)» fromDto(final «javaClassName(name)» source, final «javaClassName(base.name)» target) {
                  return fromDto(source, target, new HashMap<Object, Object>());
              }

              «javaClassName(base.name)» fromDto(final «javaClassName(name)» source, final «javaClassName(base.name)» target, final Map<Object, Object> translated) {
                  Object translatedObject = translated.get(source);
                  if (translatedObject != null) {
                      return («javaClassName(base.name)»)translatedObject;
                  }

                  Assert.notNull(source, "argument [source] may not be null");
                  Assert.notNull(target, "argument [target] may not be null");

                  final boolean equals = (source.getId() == null) ? target.getId() == null
                                                                  : source.getId().equals(target.getId());

                  if (!equals) {
                      throw new IllegalArgumentException("Can not translate a dto to a domain object when the id of the dto differs from the id of the domain object.");
                  }

                  validateVersion(source, target);

                  target.activateValidation(false);

                  «FOREACH properties.typeSelect(DtoDataProperty).select(e|e.writable) AS dataProperty -»
                      «IF !dataProperty.nullable && !dataProperty.mandatoryForCreation»if (source.«getterPrefix(dataProperty)»«javaClassName(dataProperty.name)»() != null) {«ENDIF-»
                          «IF dataProperty.metaType == DtoEnumerationProperty -»
                              target.set«javaClassName(dataProperty.name)»(«dataProperty.name»Translator.fromDto(source.get«javaClassName(dataProperty.name)»()));
                          «ELSE -»
                              target.set«javaClassName(dataProperty.name)»(source.«getterPrefix(dataProperty)»«javaClassName(dataProperty.name)»());
                          «ENDIF -»
                      «IF !dataProperty.nullable && !dataProperty.mandatoryForCreation»}«ENDIF»
                  «ENDFOREACH»
 
                  translated.put(source, target);
                  «FOREACH  associationProperties AS assRef -»
                    «LET assRef.dtoType.getBaseDtoBusinessClassName() AS assRefBusinessClass»
                    «LET assRef.dtoType.getBaseDtoName() AS assRefDto»
                    «LET javaTranslatorName(javaClassName(assRef.dtoType.getBaseDtoName())).toFirstLower() AS assRefTranslator»
                         /*
                          * Synchronize «assRef.name.toFirstUpper()» association.
                          */
   «REM»2Many«ENDREM» «IF assRef.multiplicity == Multiplicity::MANY -»
                             Set<«assRefBusinessClass»> «assRef.name»ToBeRemoved = new HashSet<«assRefBusinessClass»>(
                                          target.get«assRef.name.toFirstUpper()»().size());
                          /* Avoid changing the collection underneath an active iterator. */
                          for («assRefBusinessClass» element : target.get«assRef.name.toFirstUpper()»()) {
                              if (source.getFrom«assRef.name.toFirstUpper()»(element.getId()) == null) {
                                  «assRef.name»ToBeRemoved.add(element);
                              }
                          }
                          /* Objects to be removed */
                          for («assRefBusinessClass» element : «assRef.name»ToBeRemoved) {
                              target.removeFrom«assRef.name.toFirstUpper()»(element);
                          }
                          for («assRefDto» element : source.get«assRef.name.toFirstUpper()»()) {
                              if (element.getId() == null) {
                                  /* A new object to be added */
                                  target.addTo«assRef.name.toFirstUpper()»(«assRefTranslator».fromDto(element, translated));
                              } else {
                          «REM»start new code«ENDREM»
                                /* An existing object to be updated */
                                if( target.getFrom«assRef.name.toFirstUpper()»(element.getId())  == null ){
                                    // Element is not in target yet, read it from the store and add to target
                                    «assRefBusinessClass» original = «assRefBusinessClass.toFirstLower()»Dao.retrieve(element.getId());
                                    «assRefBusinessClass» updated = «assRefTranslator».fromDto(element, original, translated);
                                    target.addTo«assRef.name.toFirstUpper()»(updated);
                                } else {
                                    // Element is in target already, use this object. No need to add to the collection
                                  «assRefTranslator».fromDto(element, target.getFrom«assRef.name.toFirstUpper()»(element.getId()), translated);
                                }
                            }
                        }

                          «REM»end new code«ENDREM»
   «REM»2One«ENDREM» «ELSE»
                         if (source.get«assRef.name.toFirstUpper()»() == null ) {
                             /* Delete associated object */
                             target.set«assRef.name.toFirstUpper()»(null);
                         } else {                         // source.get«assRef.name.toFirstUpper()»() != null ) {
                                 /* Add a new associated object */
                               if( source.get«assRef.name.toFirstUpper()»().getId() != null ){
                                /* Add an existing object */
                                «assRefBusinessClass» original = «assRefBusinessClass.toFirstLower()»Dao.retrieve(source.get«assRef.name.toFirstUpper()»().getId());
                                «assRefBusinessClass» updated  = «assRefTranslator».fromDto(source.get«assRef.name.toFirstUpper()»(), original, translated);
                                target.set«assRef.name.toFirstUpper()»(updated);
                             } else  {
                                 /* Add a new object */
                                 target.set«assRef.name.toFirstUpper()»(«assRefTranslator».fromDto(source.get«assRef.name.toFirstUpper()»(), translated));
                             }
                         }
                     «ENDIF»
                     «ENDLET»
                     «ENDLET»
                     «ENDLET»
                  «ENDFOREACH»
                  target.activateValidation(true);

                  return target;
              }

             /**
              * Translates a «javaClassName(base.name)» domain object into a «javaClassName(name)» dto object. Properties and associations of the domain object
              * will be mapped to the corresponding properties and associations in the dto object.
              * To prevent looping while translating biderectional or circulair associations translated objects will be added to the 'translated' register.
              *
              * @param source The {@link «javaClassName(base.name)»} object to translate.
              *
              * @return «javaClassName(name)» The {@link «javaClassName(name)»} object translated from source.
              */
              public «javaClassName(name)» toDto(final «javaClassName(base.name)» source) {
                return toDto(source, new HashMap<Object, Object>());
              }

              «javaClassName(name)» toDto(final «javaClassName(base.name)» source, final Map<Object, Object> translated) {
                  Object translatedObject = translated.get(source);
                  if (translatedObject != null) {
                      assert translatedObject instanceof «javaClassName(name)» : "Multiple instances of a business domain object in the same object graph may not be translated to different DTO objects";
                      return («javaClassName(name)»)translatedObject;
                  }

                  Assert.notNull(source, "argument [source] may not be null");

                  «javaClassName(name)» result = new «javaClassName(name)»(source.getId(), source.getVersion());
                  «FOREACH properties.typeSelect(DtoDataProperty) AS dataProperty -»
                      «IF dataProperty.metaType == DtoEnumerationProperty -»
                          result.set«javaClassName(dataProperty.name)»(«dataProperty.name»Translator.toDto(source.get«javaClassName(dataProperty.name)»()));
                      «ELSE -»
                          result.set«javaClassName(dataProperty.name)»(source.«getterPrefix(dataProperty)»«javaClassName(dataProperty.name)»());
                      «ENDIF -»
                  «ENDFOREACH»

                  translated.put(source, result);
                  «FOREACH associationProperties AS assRef -»
                     «LET javaTranslatorName(javaClassName(assRef.dtoType.getBaseDtoName())).toFirstLower() AS assRefTranslator»
                     «IF assRef.multiplicity == Multiplicity::MANY -»
                           for («assRef.dtoType.getBaseDtoBusinessClassName()» element: source.get«assRef.name.toFirstUpper()»()) {
                              result.addTo«assRef.name.toFirstUpper()»(«assRefTranslator».toDto(element, translated));
                          }
                     «ELSE -» «REM»2One«ENDREM»
                         if( source.get«assRef.name.toFirstUpper()»() != null ) {
                             result.set«assRef.name.toFirstUpper()»(«assRefTranslator».toDto(source.get«assRef.name.toFirstUpper()»(), translated));
                         }
                     «ENDIF -»
                     «ENDLET-»
                  «ENDFOREACH»
                  return result;
              }

              «EXPAND exampleFromDto FOR this»


          /**
            * Validates that the version of the DTO and the business object are valid.
            * The DTO may only have a version if the domain object also has a version.
            * When they both have a version and the DTO version is less, another user
            * has updated the domain object in the meantime, if it is equal, all is
            * well. If it is more, an unexpected situation occurs: the DTOs is more new
            * then the domain object: this is not possible.
            *
            * @param source
            *            The DTO.
            * @param target
            *            The domain object target.
            */
           private void validateVersion(final «javaClassName(name)» source, final «javaClassName(base.name)» target) {
               final Integer sourceVersion = source.getVersion();
               final Integer targetVersion = target.getVersion();

                       // FIXME the DTO translator should not know that -1 is the default unpersisted value!
                       final boolean equals = (sourceVersion == null) ? targetVersion == -1
                                                                      : sourceVersion.equals(targetVersion);

               if (!equals) {
                   throw new ConcurrentUpdateException("Versions of source and target do not match for dto " + source +
                                                         ", source is " + sourceVersion +
                                                         ", target is " + targetVersion + ".");
               }
           }
           }
   «ENDLET»
«ENDDEFINE»

«DEFINE exampleFromDto FOR BusinessClassDto»
«LET this.base.name.javaDomainExampleClass() AS ExampleClass»
«LET this.base.name.javaDomainClass() AS Class»

 /**
  * Translates a «javaClassName(name)» dto object into a «ExampleClass»Example object.
  * All properties, including the id property, in the dto will be mapped to the corresponding property in the
  * <code>target</code> domain object.
  * Also translates all To-One association references in the dto, into the resulting example object.
  * All To-Many associations will be ignored and are <strong>not</strong> translated inot the resulting example object.
  *
  * @param source The {@link «javaClassName(name)»} object to translate.
  *
  * @return {@link «ExampleClass»}, the resulting example object.
  */
  public «ExampleClass» exampleFromDto(final «javaClassName(name)» source) {
  
      Assert.notNull(source, "argument [source] may not be null");

      «ExampleClass» result = new «ExampleClass»(source.getId());
      «FOREACH properties.typeSelect(DtoDataProperty).select(e|e.writable) AS dataProperty -»
          «IF dataProperty.metaType == DtoEnumerationProperty -»
              result.set«javaClassName(dataProperty.name)»(«dataProperty.name»Translator.fromDto(source.get«javaClassName(dataProperty.name)»()));
          «ELSE -»
              result.set«javaClassName(dataProperty.name)»(source.«getterPrefix(dataProperty)»«javaClassName(dataProperty.name)»());
          «ENDIF -»
      «ENDFOREACH»
      
     «REM»Process associations.«ENDREM»
     «FOREACH this.properties.typeSelect(DtoAssociationRoleProperty) AS assRef -»
         «LET javaTranslatorName(javaClassName(assRef.dtoType.getBaseDtoName())).toFirstLower() AS assRefTranslator»
         «IF assRef.multiplicity == Multiplicity::MANY -»
             «REM»For now all To-Many associations are ignored.«ENDREM»
         «ELSE» 
            «REM»To-One association.«ENDREM»
            result.set«assRef.name.toFirstUpper()»(«assRefTranslator».exampleFromDto(source.get«assRef.name.toFirstUpper()»())); 
         «ENDIF»
         «ENDLET»
     «ENDFOREACH»
     return result;
 }
«ENDLET»
«ENDLET»
«ENDDEFINE»

«DEFINE getBaseDtoName FOR Dto -»
    «REM»Nothing to generate for this superclass«ENDREM»
«ENDDEFINE»

«DEFINE getBaseDtoName FOR BusinessClassDto -»
    «javaClassName(name) -»
«ENDDEFINE»

«DEFINE getBaseDtoBaseName FOR Dto -»
    «REM»Nothing to generate for this superclass«ENDREM»
«ENDDEFINE»

«DEFINE getBaseDtoBaseName FOR BusinessClassDto -»
    «javaClassName(base.name) -»
«ENDDEFINE»
