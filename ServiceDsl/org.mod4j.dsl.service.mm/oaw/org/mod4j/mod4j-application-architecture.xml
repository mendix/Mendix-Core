<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4/EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
<!ENTITY mod4j "<ulink url='http://www.mod4j.org/'>Mod4j</ulink>">
]>
<book lang="en">
  <bookinfo>
    <title>&mod4j; Application Architecture</title>
    <author>
      <firstname>Eric</firstname>
      <othername>Jan</othername>
      <surname>Malotaux</surname>
    </author>
    <releaseinfo>&version;</releaseinfo>
    <copyright>
      <year>2008-2009</year>
    </copyright>
  </bookinfo>
  <chapter>
    <title>Introduction</title>
    <section>
      <title>Purpose</title>
      <para>The purpose of this document is to describe the architecture of web applications
        generated by &mod4j;. Users of &mod4j; need to understand this in order to be able
        to extend the generated application.</para>
    </section>
    <section>
      <title>References</title>
      <anchor id="bibliography"/>
      <bibliography>
        <biblioentry id="busch96">
          <abbrev>Busch96</abbrev>
          <title>Pattern-Oriented Software Architecture - A System of Patterns</title>
          <authorgroup>
            <author>
              <firstname>Frank</firstname>
              <surname>Buschmann</surname>
            </author>
            <author>
              <surname>Meunier</surname>
              <firstname>Regine</firstname>
            </author>
            <author>
              <surname>Rohnert</surname>
              <firstname>Hans</firstname>
            </author>
            <author>
              <surname>Sommerlad</surname>
              <firstname>Peter</firstname>
            </author>
            <author>
              <surname>Stal</surname>
              <firstname>Michael</firstname>
            </author>
          </authorgroup>
          <publisher>
            <publishername>John Wiley &amp; Sons</publishername>
          </publisher>
          <date>1996</date>
        </biblioentry>
        <biblioentry id="evans03">
          <abbrev>Evans03</abbrev>
          <title>Domain-Driven Design: Tackling Complexity in the Heart of Software</title>
          <author>
            <firstname>Eric</firstname>
            <surname>Evans</surname>
          </author>
          <publisher>
            <publishername>Addison-Wesley</publishername>
          </publisher>
          <date>2003</date>
          <isbn>0-321-12521-5</isbn>
        </biblioentry>
        <biblioentry id="fowler02">
          <abbrev>Fowler02</abbrev>
          <author>
            <firstname>Martin</firstname>
            <surname>Fowler</surname>
          </author>
          <title>Patterns of Enterprise Application Architecture</title>
          <publisher>
            <publishername>Addison-Wesley</publishername>
          </publisher>
          <date>2002</date>
          <isbn>0-321-12742-0</isbn>
        </biblioentry>
        <biblioentry id="spring25">
          <abbrev>Spring25</abbrev>
          <authorgroup>
            <author>
              <firstname>Rod</firstname>
              <surname>Johnson et al.</surname>
            </author>
          </authorgroup>
          <title>java/j2ee Application Framework</title>
          <subtitle>The Spring Framework - Reference Documentation</subtitle>
          <releaseinfo>Version 2.5</releaseinfo>
          <copyright>
            <year>2004-2007</year>
          </copyright>
        </biblioentry>
      </bibliography>
    </section>
    <section>
      <title>Abbreviations</title>
      <glosslist>
        <glossentry>
          <glossterm id="ACID">ACID</glossterm>
          <glossdef>
            <para>Atomicity, Consistency, Isolation, Durability</para>
          </glossdef>
        </glossentry>
        <glossentry>
          <glossterm id="CRUD">CRUD</glossterm>
          <glossdef>
            <para>Create, Read, Update, Delete</para>
          </glossdef>
        </glossentry>
        <glossentry>
          <glossterm id="DSL">DSL</glossterm>
          <glossdef>
            <para>Domain-Specific Language</para>
          </glossdef>
        </glossentry>
        <glossentry>
          <glossterm id="DRY">DRY</glossterm>
          <glossdef>
            <para>Don&apos;t repeat yourself</para>
          </glossdef>
        </glossentry>
        <glossentry>
          <glossterm id="DTO">DTO</glossterm>
          <glossdef>
            <para>Data Transfer Object</para>
          </glossdef>
        </glossentry>
        <glossentry>
          <glossterm id="EJB">EJB</glossterm>
          <glossdef>
            <para>Enterprise JavaBean</para>
          </glossdef>
        </glossentry>
        <glossentry>
          <glossterm id="JDBC">JDBC</glossterm>
          <glossdef>
            <para>Java Database Connectivity</para>
          </glossdef>
        </glossentry>
        <glossentry>
          <glossterm id="JDK">JDK</glossterm>
          <glossdef>
            <para>Java Development Kit</para>
          </glossdef>
        </glossentry>
        <glossentry>
          <glossterm id="MDD">MDD</glossterm>
          <glossdef>
            <para>Model-Driven Development</para>
          </glossdef>
        </glossentry>
        <glossentry>
          <glossterm id="ORM">ORM</glossterm>
          <glossdef>
            <para>Object-Relational Mapping</para>
          </glossdef>
        </glossentry>
        <glossentry>
          <glossterm id="POJO">POJO</glossterm>
          <glossdef>
            <para>Plain Old Java Object</para>
          </glossdef>
        </glossentry>
        <glossentry>
          <glossterm id="REST">REST</glossterm>
          <glossdef>
            <para>Representational State Transfer</para>
          </glossdef>
        </glossentry>
        <glossentry>
          <glossterm id="RMI">RMI</glossterm>
          <glossdef>
            <para>Remote Method Invocation</para>
          </glossdef>
        </glossentry>
        <glossentry>
          <glossterm id="SOA">SOA</glossterm>
          <glossdef>
            <para>Service-Oriented Architecture</para>
          </glossdef>
        </glossentry>
        <glossentry>
          <glossterm id="SOAP">SOAP</glossterm>
          <glossdef>
            <para>Simple Object Access Protocol</para>
          </glossdef>
        </glossentry>
        <glossentry>
          <glossterm id="SQL">SQL</glossterm>
          <glossdef>
            <para>Structured Query Language</para>
          </glossdef>
        </glossentry>
      </glosslist>
    </section>
    <section>
      <title>Structure of this document</title>
      <para>Chapter 2 describes the logical structure of an application generated by &mod4j; ,
        while chapter 3 describes its technical structure.</para>
    </section>
  </chapter>
  <chapter>
    <title>Logical View</title>
    <section>
      <title>Overview</title>
      <para>This chapter describes the logical composition of the &mod4j; Reference
        Architecture. It defines the layers, the component types in each layer and the
        responsibilities of these component types.</para>
      <para>
        <figure>
          <title>Logical view</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/logical-view.jpg" format="JPG"/>
            </imageobject>
          </mediaobject>
        </figure>
      </para>
      <para>The <emphasis>Layers</emphasis> architectural pattern itself is described in <biblioref
          linkend="busch96"/>. The <emphasis>Presentation Layer</emphasis> provides an interface to
        the system to a human user, presenting information and interpreting actions of the user. It
        uses the Service Layer to obtain the information or execute other operations that the
        Service Layer offers. The <emphasis>Service Layer</emphasis> provides access to the services
        of the Business Layer using a particular access protocol, like <glossterm linkend="SOAP"
          >SOAP</glossterm>, <glossterm linkend="EJB">EJB</glossterm>, <glossterm linkend="RMI"
          >RMI</glossterm> or local method invocation. The <emphasis>Business Layer</emphasis>
        provides services that implement functionality and business logic. The <emphasis>Data
          Layer</emphasis> provides access to persistent data on behalf of the Business Layer. The
          <emphasis>Domain Model</emphasis> consists of classes that model the part of the world
        that the application is about. The next paragraphs describes the responsibilities and the
        structure of the layers in more detail.</para>
    </section>
    <section>
      <title>Presentation Layer</title>
      <para>The Presentation Layer contains components that present information to a user and
        interprets his actions by executing functions of the system.Typical responsibilities of the
        Presentation Layer include:</para>
      <itemizedlist>
        <listitem>
          <para>Presenting data to the user. This implies mapping fields on a screen to attibutes of
              <emphasis>Data Transfer Objects</emphasis> received from the Service Layer, formatting
            of data, internationalisation en localisation of data.</para>
        </listitem>
        <listitem>
          <para>Accepting data entered by the user. This implies applying simple validations on the
            data entered and keeping track of this data.</para>
        </listitem>
      </itemizedlist>
      <para>This Presentation Layer should not execute business functionality by itself, but instead
        delegate that responsibility to the Service Layer by calling its operations. Data is
        transferred to and from the Service Layer in the form of <emphasis>Data Transfer
          Objects</emphasis>.</para>
      <para>TODO: expand this section when the User Interface <glossterm linkend="DSL"
          >DSL</glossterm> is nearer to completion.</para>
    </section>
    <section>
      <title>Service Layer</title>
      <para>The primary responsibility of the <emphasis>Service Layer</emphasis> is to isolate the
        business layer from the various protocols in use for remotely invoking its service
        operations. Examples of such protocols are <glossterm linkend="SOAP">SOAP</glossterm> or
          <glossterm linkend="REST">REST</glossterm>ful Web Services, messaging, <glossterm
          linkend="EJB">EJB</glossterm>, <glossterm linkend="RMI">RMI</glossterm> or plain old local
        mehod calls. A service layer presents the interface of the business layer in the form
        required for one particular access protocol. Therefore, a separate service layer is needed
        for each protocol by which the system will be accessed. This makes it clear that the
        presentation layer should not contain any business functionality, because that would have to
        be duplicated for each separate service layer. Code duplication is bad: it violates the
          <glossterm linkend="DRY">DRY</glossterm> (Don&apos;t Repeat Yourself) principle.<footnote>
          <para>See for example: <ulink url="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself"
              >http://en.wikipedia.org/wiki/Don&apos;t_repeat_yourself</ulink></para>
        </footnote></para>
      <para>In addition, the service layer is reponsible for:<itemizedlist>
          <listitem>
            <para>authentication and authorisation of the calling identities</para>
          </listitem>
          <listitem>
            <para>exposing a collection of <emphasis>Data Transfer Objects</emphasis> to be used for
              transferring data between the service layer and its callers</para>
          </listitem>
          <listitem>
            <para>translation of the information in the data transfer objects used for communication
              with the presentation layer to and from <emphasis>Domain Model</emphasis> objects used
              for communication with the business layer</para>
          </listitem>
          <listitem>
            <para>making the call to each service operation an atomic (<glossterm linkend="ACID"
                >ACID</glossterm>) transaction.</para>
          </listitem>
        </itemizedlist></para>
      <section>
        <title>Data Transfer Objects</title>
        <para>The purpose of Data Transfer Objects (<glossterm linkend="DTO"
          >DTO</glossterm>&apos;s) is to decouple the core of the application from client
          applications, including the user interface, that communicate with it. A collection of
            <glossterm linkend="DTO">DTO</glossterm>&apos;s form a common vocabulary between the
          communicating applications. In a <glossterm linkend="SOA">SOA</glossterm> environment for
          instance, an application will commonly be required to communicate with other applications
          using a common <emphasis>canonical datamodel</emphasis>, that is defined outside of the
          control of the application we have to develop.</para>
        <para><glossterm linkend="DTO">DTO</glossterm>&apos;s are very similar in structure to
          domain model classes. They have properties and can have references to other <glossterm
            linkend="DTO">DTO</glossterm>&apos;s. They do not have validators and no
          constructors with mandatory fields. All properties are nullable.</para>
        <para>For each <glossterm linkend="DTO">DTO</glossterm> there is a correponding
            <classname>Translator</classname> class. A <classname>Translator</classname> defines two
          methods: <methodname>toDto</methodname> and <methodname>fromDto</methodname>. The
            <methodname>toDto</methodname> method translates a domain model object into a <glossterm
            linkend="DTO">DTO</glossterm> that is based on it. When a <glossterm linkend="DTO"
            >DTO</glossterm> has references to other <glossterm linkend="DTO"
          >DTO</glossterm>&apos;s that corresponds to references of the domain model class,
          those object are also translated, recursively. The translators operate within a
          transaction and therefore also on objects connected to the same Hibernate session. That
          means that while traversing associated domain object to translate into their corresponding
            <glossterm linkend="DTO">DTO</glossterm>&apos;s, the translator may cause Hibernate
            <emphasis>lazy loading</emphasis> to retrieve objects from the database
          automatically.</para>
      </section>
    </section>
    <section>
      <title>Business Layer</title>
      <para>The <emphasis>Business Layer</emphasis> is a <emphasis>facade</emphasis> for the
          <emphasis>Domain Model</emphasis>. It exposes the business functionality of the
        application in the form of methods, with arguments and return values from the domain model.
        These methods:<itemizedlist>
          <listitem>
            <para>persist and retrieve domain objects by delegating to the <emphasis>Data
                Layer</emphasis></para>
          </listitem>
          <listitem>
            <para>delegate to domain model objects to execute reusable business functionality</para>
          </listitem>
          <listitem>
            <para>implement business logic specific to a single business process</para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section>
      <title>Data Layer</title>
      <para>The responsibility of the <emphasis>Data Layer</emphasis> is to persist and retrieve
        data. The data is transferred between the data layer and its calling business layer in the
        form of arguments and return values based on the domain model. The persistence logic is
        dependent on the particular persistence technology in use, like a relational database,
        textfiles, XML documents or an XML database, or another application that exposes services
        for accessing data.</para>
      <para>The data layer contains a number of data access objects, in principle one for each
        domain model class. Each such object:<itemizedlist>
          <listitem>
            <para>Has <glossterm linkend="CRUD">CRUD</glossterm>-methods to create (C), retrieve
              (R), update (U) or delete (D) data contained in one domain model object</para>
          </listitem>
          <listitem>
            <para>Can have methods to retrieve a list of objects based on a query</para>
          </listitem>
          <listitem>
            <para>Must transform data from the domain model to the format in which they are
              persisted, and vice versa. This is done with <emphasis role="italic"
                >Hibernate</emphasis> a Object-Relational Mapping (<glossterm linkend="ORM"
                >ORM</glossterm>) framework, like or <emphasis role="italic"
              >Toplink</emphasis>.</para>
          </listitem>
          <listitem>
            <para>Can offer paging facilities when a large result set may be retrieved.</para>
          </listitem>
          <listitem>
            <para>May not maintain state.</para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section>
      <title>Domain Model</title>
      <para>The <emphasis>Domain Model</emphasis> contains classes that model the part of the world
        that the application is about. The domain model is developed in an object oriented way as
        advocated by <biblioref linkend="fowler02"/> and <biblioref linkend="evans03"/>. As much
        business functionality as possible is implemented as methods on domain model classes. Domain
        model objects:<itemizedlist>
          <listitem>
            <para>Should expose methods that perform business actions or complex
              computations.</para>
          </listitem>
          <listitem>
            <para>Should not be aware of persistence-related issues. Domain model objects should not
              have to worry about whether or not they are persisted, and how. For instance: they
              should not have create, retrieve, update or delete methods.</para>
          </listitem>
          <listitem>
            <para>Trigger validation of business rules at any state change. Business rule violations
              are reported by raising an exception. When more than one business rule is violated by
              a state change, only one exception is raised that contains information about each
              one.</para>
          </listitem>
          <listitem>
            <para>May leave the validation of certain types of business rule to lower layers, like
              the database. Good candidates for instance are unique rules, that are easily enforced
              by a relational database by defining unique constraints. The downside of this approach
              is that business rule violations in these cases are raised at a different moment than
              ordinary business, and that they have to be treated differently.</para>
          </listitem>
          <listitem>
            <para>May trigger events to notify other interested objects of state changes.</para>
          </listitem>
        </itemizedlist></para>
    </section>
  </chapter>
  <chapter>
    <title>Implementation View</title>
    <para>This chapter describes how the architectural layers described in the previous chapter are
      implemented. It describes how the code is divided into modules, how the Java classes are
      organised in packages, which frameworks are being used and in what way.</para>
    <section>
      <title>Modules</title>
      <para>The application is implemented as a <emphasis role="italic">
          <ulink url="http://maven.apache.org/">Maven</ulink>
        </emphasis> project, consisting of a <emphasis role="italic">parent</emphasis> project of
        type <emphasis role="italic">pom</emphasis>, and a number of modules, one for each layer of
        the Logical View. The modules are contained in subdirectories of the directory of the parent
        project.</para>
      <para>The names of the modules are formed by concatenating the &mod4j; Project Name, a
        dash ("-") and a keyword derived from the architectural layer the module implements. For a
        hypothetical &mod4j; project "RecordShop", the module names would be:
          <literal>RecordShop-service</literal>, <literal>RecordShop-business</literal>,
          <literal>RecordShop-data</literal> and <literal>RecordShop-domain</literal>.</para>
      <para>The Maven project can be built by Maven from the command-line. Alternatively, the
        modules may be imported into Eclipse with the <emphasis role="italic">
          <ulink url="http://code.google.com/p/q4e/">Q4E</ulink>
        </emphasis>-plugin, and built from within Eclipse.</para>
    </section>
    <section>
      <title>Packages</title>
      <para>The Java classes are organised in Java packages. The package names are prefixed with a
        root package name provided by the user at the time the &mod4j; project was created by
        the &mod4j; Project Creation Wizard. After project creation the root package name is
        stored in the file <filename>src/model/mod4j.properties</filename> as the value of the
        property <varname>rootPackage</varname>. This file can be edited manually to change the root
        package name. The packages names below this common prefix start with a package name
        corresponding with the component name, that in turn is derived from the architectural layer
        that it implements.</para>
      <table>
        <title>Packages</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Name</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <package>service</package>
              </entry>
              <entry>Interfaces and implementations of the service layer.</entry>
            </row>
            <row>
              <entry>
                <package>service.dto</package>
              </entry>
              <entry>Data Transfer Objects.</entry>
            </row>
            <row>
              <entry>
                <package>service.dto.translators</package>
              </entry>
              <entry>Java classes that translate Domain Objects to Data Transfer Objects, and vice
                versa.</entry>
            </row>
            <row>
              <entry>
                <package>business</package>
              </entry>
              <entry>Interfaces and implementations of the Domain Services in the business
                layer.</entry>
            </row>
            <row>
              <entry>
                <package>data</package>
              </entry>
              <entry>Interfaces that define the contracts of the Data Access Objects.</entry>
            </row>
            <row>
              <entry>
                <package>data.hibernate.spring</package>
              </entry>
              <entry>Spring/Hibernate specific implementations of the Data Access Object interfaces
                in the <package>data</package> package.</entry>
            </row>
            <row>
              <entry>
                <package>domain</package>
              </entry>
              <entry>Domain Objects: <glossterm linkend="POJO">POJO</glossterm> classes that
                implement the Domain Model.</entry>
            </row>
            <row>
              <entry>
                <package>domain.businessrules</package>
              </entry>
              <entry>Java classes that implement Business Rules.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section>
      <title>Spring</title>
      <para>The Spring framework is used as a general application framework. The objects making up
        the application are being wired up by the Spring framework based on a number of XML
        configuration files, generally one per layer. The Spring <ulink
          url="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/access/ContextSingletonBeanFactoryLocator.html">
          <classname>ContextSingletonBeanFactoryLocator</classname>
        </ulink> class is used to create multiple hierarchical Spring IoC container instances, also
        called bean factory or application context in Spring parlance, from these XML configuration
        files. For the container of each layer, the container of the lower layer is the parent
        container. <mediaobject>
          <imageobject>
            <imagedata fileref="images/spring-config.jpg"/>
          </imageobject>
        </mediaobject></para>
      <para>Beans defined in a direct or indirect parent context are visible in the child context,
        but not vice versa. This hierarchical container is then used as the parent container of a
        web application container. In this way, containers and the beans contained in them, may be
        shared between several web applications, and loaded only once. Moreover, the hierarchical
        composition of the container guarantees that dependencies between them are parallel to the
        depencencies between the layers of the logical view. See section <ulink
          url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-glue-code-and-singletons">
          <citetitle>3.9 Glue code and the evil singleton</citetitle>
        </ulink>in <biblioref linkend="spring25"/> and the Javadoc for <ulink
          url="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/access/ContextSingletonBeanFactoryLocator.html">
          <classname>ContextSingletonBeanFactoryLocator</classname>
        </ulink> for more details.</para>
    </section>
    <section>
      <title>Hibernate</title>
      <para><ulink url="http://www.hibernate.org/">Hibernate</ulink> is an <ulink
          url="http://en.wikipedia.org/wiki/Object-relational_mapping">object-relational
          mapping</ulink> framework used to implement the data layer. This section document the
        choices made in several area&apos; of this framework.</para>
      <section>
        <title>Mapping</title>
        <para>Hibernate offers a choice between mapping using <glossterm linkend="JDK">
            <acronym>JDK</acronym>
          </glossterm> 5.0 annotations inside the domain model classes being mapped, and mapping
          using one or more separate XML mapping documents. We choose using XML mapping documents.
          The rationale is that we want to keep persistance concerns strictly separate from pure
          business logic. This way we can more easily change mapping strategies or even persistence
          frameworks.</para>
        <para>Each persistent class is mapped in a separate XML document located in a directory
          corresponding to the fully qualified Java package of the class being mapped, and with a
          name constructed from the Java class name and a suffix ".hbm.xml". So, the fully qualified
          path relative to the package root, for an XML mapping document for a persistent class
          named <classname>org.company.recordshop.domain.Artist</classname> would be
            <filename>org/company/recordshop/domain/Artist.hbm.xml</filename>.</para>
      </section>
      <section>
        <title>Access strategy</title>
        <para>Hibernate offers a choice between two strategies to access the fields of objects:
            <emphasis>property access</emphasis>, which is the default, and <emphasis>field
            access</emphasis>. We choose the second, <emphasis>field access</emphasis>. We prefer to
          keep programmatic access to the state of the object separate from framework access. For
          example, using a setter will trigger data validation, which is clearly not necessary when
          populating an object from persistent store. And it might trigger data transformations for
          derived fields.</para>
      </section>
      <section>
        <title>Optimistic concurrency control</title>
        <para>Hibernate offers several strategies to implement concurrency control. We choose
          optimistic concurrency control based on a <property>version</property> property, with a
          negative <property>unsaved-value</property>. In the persisted class, this is a
            <property>private int</property> field named <varname>version</varname>, initialized to
          -1. The following example from a Hibernate mapping file illustrates this:<example>
            <title>Optimistic concurrency control mapping</title>
            <programlisting><![CDATA[<version name="version" unsaved-value="negative"/>]]></programlisting>
          </example>The corresponding field declaration in the mapped Java class looks like this: <example>
            <title>Optimistic concurrency control Java field</title>
            <programlisting><![CDATA[@SuppressWarnings("unused")
private int version = -1;]]></programlisting>
          </example>Since this field is only used by Hibernate, there are no access methods for
          it.</para>
      </section>
      <section>
        <title>Spring support</title>
        <para>The Java implementations of the data access objects are based on the Spring <ulink
            url="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/orm/hibernate3/support/HibernateDaoSupport.html">
            <classname>HibernateDaoSupport</classname>
          </ulink> class and its <ulink
            url="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/orm/hibernate3/HibernateTemplate.html">
            <classname>HibernateTemplate</classname>
          </ulink> helper class. This implies that all Hibernate, <glossterm linkend="SQL"
            >SQL</glossterm> and <glossterm linkend="JDBC">JDBC</glossterm> exceptions will be
          converted to an appropriate subclass of <ulink
            url="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/dao/DataAccessException.html">
            <classname>DataAccessException</classname>
          </ulink> class.</para>
      </section>
      <section>
        <title>Enumerations</title>
        <para>Java <property>enum</property>&apos;s are mapped with a specific implementation
              <classname>&lt;<replaceable>rootPackage</replaceable>&gt;.data.GenericEnumUserType</classname>
          of the Hibernate interface <ulink
            url="http://www.hibernate.org/hib_docs/v3/api/org/hibernate/usertype/UserType.html">
            <classname>org.hibernate.usertype.UserType</classname>
          </ulink>. The following example illustrates this:<example>
            <title>Enumeration mapping</title>
            <programlisting><![CDATA[<property name="sexe">
    <type name="org.company.recordshop.data.GenericEnumUserType">
        <param name="enumClass">
            org.company.recordshop.domain.SexeEnum
        </param>
    </type>
</property>]]></programlisting>
          </example>The <property>enumClass</property> must be a Java <property>enum</property>
          class with a method <methodname>id()</methodname> and a method <methodname>value(Integer
            id)</methodname>. When an object with a enumeration property is persisted, the return
          value of the <methodname>id</methodname> is stored in the database. When an object is
          loaded from the database, the enumeration instance returned by the method
            <methodname>value(Integer id)</methodname> with the persisted value as argument is set
          as the value for the enumeration property.<example>
            <title>enum Java implementation</title>
            <programlisting><![CDATA[package org.company.recordshop.domain;

import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;

/**
 * Sexe enumeration.
 */
public enum SexeEnum {

    FEMALE(1), MALE(2);

    private static final Map<Integer, SexeEnum> lookup =
        new HashMap<Integer, SexeEnum>();
    static {
        for (SexeEnum s : EnumSet.allOf(SexeEnum.class))
            lookup.put(s.id(), s);
    }

    private Integer id;

    private SexeEnum(Integer id) {
        this.id = id;
    }

    public Integer id() {
        return id;
    }

    public static SexeEnum value(Integer id) {
        return lookup.get(id);
    }
}
]]></programlisting>
          </example></para>
      </section>
      <section>
        <title>Primary keys</title>
        <para>Primary keys are instances of <classname>java.lang.Long</classname>. This field may be
          modified only by Hibernate and therefore there are no methods that modify this field. A
          getter may be useful.</para>
      </section>
    </section>
    <section>
      <title>Domain Model</title>
      <para>The domain model classes need very little framework support. They are implemented as
        Plain Old Java Objects (POJO&apos;s). The <link linkend="business_rules">business
          rule</link> implementations do rely on some classes of the Spring framework, but they are
        implemented as separate classes. The domain model classes are not in any way dependent on
        them.</para>
      <para>Domain model objects are designed to be at all times in a consistent state. To be in a
        consistent state means that all mandatory properties have a value, and that the object
        satisfies all business rules defined for the class. This principle is enforced by providing<itemizedlist>
          <listitem>
            <para>a constructor with all mandatory properties as parameters</para>
          </listitem>
          <listitem>
            <para>a set of classes that implement business rules, including rules to check for the
              presence of non-null values for mandatory properties.</para>
          </listitem>
        </itemizedlist>The busines rules must be checked whenever the state of an object changes.
        For example, at the end of the constructor with the mandatory properties, and at the end of
        every setter.</para>
      <section>
        <title>Constructors</title>
        <para>Every domain model class needs at least two constructors. One of these is a
          no-argument constructor that is used by Hibernate. This constructor is not intented to be
          used for any other purpose, so it must be declared with the least visibility that still
          allows it to be used by Hibernate. This is <property>protected</property> visibility. This
          contructor must be present, but does not have to do anything. The other constructor takes
          all mandatory properties as parameters. The actual argument values for these parameters
          must be validated using the appropriate business rules.</para>
      </section>
      <section>
        <title>equals and hashcode</title>
        <para>All domain model classes must override the standard methods
            <methodname>equals</methodname> and <methodname>hashcode</methodname> in a consistent
          way. Two domain model class instances are considered equal either if they are the same
          objects, or if they belong to the same class <emphasis>and</emphasis> have the same value
          for their <property>id</property> property. The hashcode could return the hashcode of the
            <property>id</property> property if it is non-null, and the hashcode of the superclass
          if it is <property>null</property>.</para>
      </section>
      <section>
        <title id="business_rules">Business rules</title>
        <para>Business rules are implemented as separate classes, one class per business rule. The
          business rule implementation are based on two interfaces from the Spring framework: <ulink
            url="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/validation/Validator.html">
            <classname>Validator</classname>
          </ulink> and <ulink
            url="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/validation/Errors.html">
            <classname>Errors</classname>
          </ulink> as described in the paragraph <ulink
            url="http://static.springframework.org/spring/docs/2.5.x/reference/validation.html#validator"
            >5.2 Validation using Spring&apos;s Validator interface</ulink> of <biblioref
            linkend="spring25"/>. A difference between our approach and the one from the Spring
          manual is, that we provide a separate validator for each business rule instead of one per
          domain class. Of course many types of validators can easily be parameterised and re-used
          in different situations.</para>
        <para>The business rules implementations must be invoked after every change of state to the
          object that could possibly violate the rule.</para>
      </section>
    </section>
  </chapter>
</book>
